#include "Field.h"
#include "FieldProperties.h"
#include "Vector.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Field ParseField(char *filepath, fieldproperties properties) {
    //expected input is the CSV generated by the python script. 

    FILE* file = fopen(filepath, 'r');

    Field output;
    long double Xstep = properties.Xstep;
    long double Ystep = properties.Ystep;
    long double Zstep = properties.Zstep;

    //preliminary readings
    output.startX = properties.XStart;
    output.steplengthX = Xstep;

    output.startY = properties.YStart;
    output.steplengthY = Ystep;
    
    output.startZ = properties.ZStart;
    output.steplengthZ = Zstep;

    //this could be updated to include 2D fields.
    if(Xstep == 0 || Ystep == 0 || Zstep == 0) {
        fprintf(stderr, "0 steplength for X, Y or Z is not allowed in this program, please use a valid 3D field");
        EXIT_FAILURE;
    }

    //distrust of floating point inaccuracies.
    int xsize = (int)(((properties.Xend-properties.XStart)/Xstep)+1);
    int ysize = (int)(((properties.Yend-properties.YStart)/Ystep)+1);
    int zsize =(int)(((properties.Zend-properties.ZStart)/Zstep)+1);

    //initialise arrays based on (hopefully good) size estimates.
    //the floating poitns here are a headache
    output.FieldValues = calloc(sizeof(Vector**), xsize);
    for (int i = 0; i< xsize; i++) {
        output.FieldValues[i] = calloc(sizeof(Vector*), ysize);
        for (int j = 0; j< ysize; j++) {
            output.FieldValues[i][j] = calloc(sizeof(Vector), zsize);
        }
    }

    //preliminary declarations for the loop
    long double currentZ;
    long double currentY;
    long double currentX;
    long double newZ = properties.ZStart;
    long double newY = properties.YStart;
    long double newX = properties.XStart;
    int xindex = 0;
    int yindex = 0;
    int zindex = 0;

    do {
        do {
            do {
                Vector newVec;
                currentX = newX; 
                currentY = newY; 
                currentZ = newZ; 
                newX = 0; // read X position
                newY = 0; // read Y position
                newZ = 0; // read Z position

                newVec.x = 0; // read X value
                newVec.y = 0; // read Y value
                newVec.z = 0; // read Z value
                output.FieldValues[xindex][yindex][zindex] = newVec;
                xindex++;

                //size checks
                //this *should* only happen once at most, but floating points are not to be trusted.
                if(xindex > xsize) {
                    xsize += 100;
                    realloc(output.FieldValues, sizeof(Vector**)*xsize);
                }
                if(output.lengthX <= xindex) {
                    output.lengthX = xindex+1;
                }

            } while ((Xstep < 0 && newX < (currentX - (Xstep/2))) ||(Xstep > 0 && newX > (currentX - (Xstep/2))));

            yindex++;
            //size checks
            if(yindex > ysize) {
                ysize += 100;
                realloc(output.FieldValues[xindex], sizeof(Vector*)*xsize);
            }
            if(output.lengthY <= yindex) {
                output.lengthY = yindex+1;
            }

        } while ((Ystep < 0 && newY < (currentY - (Ystep/2))) ||(Ystep > 0 && newY > (currentY - (Ystep/2))));
  
    zindex++;
    if(zindex>zsize) {
        zsize +=100;
        realloc(output.FieldValues[xindex][yindex], sizeof(Vector)*zsize);
    }
    if(output.lengthZ <= yindex) {
        output.lengthZ = zindex +1;
    }

    } while ((Zstep < 0 && newZ < (currentZ - (Zstep/2))) ||(Zstep > 0 && newZ > (currentZ - (Zstep/2))));

    return output;
}